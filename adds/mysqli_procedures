BEGIN

INSERT INTO dstorage.tasklist(tasklistid, taskid, taskname, tasktime) 
VALUES(NULL, new.taskid, 'temmp_taskname', 3333);

END



SELECT T.taskstate FROM taskstate T WHERE 'T.taskstateid' = 0 OR 'T.taskstateid' = 1

SELECT
CURDATE() as Today,
concat(IF(TD.day='all',DAYOFMONTH(CURDATE()),TD.day), '/', IF(TD.month='all',MONTH(CURDATE()),TD.month)) as Date,
concat(TT.hours, ':', TT.minutes) as Time,
T.taskid as id,
T.taskname as Name,
CC.classcountryname as Country,
TS.taskstate as State
FROM tasks T
RIGHT JOIN taskdates TD on TD.taskid = T.taskid
RIGHT JOIN tasktimes TT on TT.taskid = T.taskid
RIGHT JOIN classcountry CC on CC.ClassCountryID = T.taskcountry
RIGHT JOIN taskstate TS on TS.taskstateid = T.taskinitstate
WHERE
(TD.year = 2016 or TD.year = 'all')
AND
(TD.month = 4 or TD.month = 'all')
AND
(TD.week = 4 or TD.week = 'all')
AND
(TD.weekday = 4 or TD.weekday = 'all')
AND
(TD.day = 3 or TD.day = 'all')
ORDER BY TD.day, TT.hours



SELECT
CURDATE() as Today,
concat(IF(TD.day='all',DAYOFMONTH(CURDATE()),TD.day), '/', IF(TD.month='all',MONTH(CURDATE()),TD.month)) as Date,
concat(TT.hours, ':', TT.minutes) as Time,
T.taskid as id,
T.taskname as Name,
CC.classcountryname as Country,
TS.taskstate as State
FROM tasks T
RIGHT JOIN taskdates TD on TD.taskid = T.taskid
RIGHT JOIN tasktimes TT on TT.taskid = T.taskid
RIGHT JOIN classcountry CC on CC.ClassCountryID = T.taskcountry
RIGHT JOIN taskstate TS on TS.taskstateid = T.taskinitstate
WHERE
(TD.year = YEAR(CURDATE()) or TD.year = 'all')
AND
(TD.month = MONTH(CURDATE()) or TD.month = 'all')
AND
(TD.week = WEEK(CURDATE()) or TD.week = 'all')
AND
(TD.weekday = WEEKDAY(CURDATE()) or TD.weekday = 'all')
AND
(TD.day = DAYOFMONTH(CURDATE()) or TD.day = 'all')
ORDER BY TD.month, TD.day, TT.hours



DROP PROCEDURE IF EXISTS taskListSelect;

DELIMITER #
CREATE PROCEDURE taskListSelect()
BEGIN
DECLARE enddate DATE DEFAULT ADDDATE(CURDATE(), 11);
DECLARE today DATE DEFAULT CURDATE();
DECLARE year, month, week, weekday, day INT;

WHILE today < enddate DO

	SET year = YEAR(today);
	SET month = MONTH(today);
	SET week = WEEK(today);
	SET weekday = WEEKDAY(today);
	SET day = DAYOFMONTH(today);

	SELECT	
	concat(IF(TD.day='all',day,TD.day), '/', IF(TD.month='all',month,TD.month)) as Date,
	concat(TT.hours, ':', TT.minutes) as Time,
	T.taskid as id,
	T.taskname as Name,
	CC.classcountryname as Country,
	TS.taskstate as State
	FROM tasks T
	RIGHT JOIN taskdates TD on TD.taskid = T.taskid
	RIGHT JOIN tasktimes TT on TT.taskid = T.taskid
	RIGHT JOIN classcountry CC on CC.ClassCountryID = T.taskcountry
	RIGHT JOIN taskstate TS on TS.taskstateid = T.taskinitstate
	WHERE
		(TD.year = year or TD.year = 'all')
		AND
		(TD.month = month or TD.month = 'all')
		AND
		(TD.week = week or TD.week = 'all')
		AND
		(TD.weekday = weekday or TD.weekday = 'all')
		AND
		(TD.day = day or TD.day = 'all')
	ORDER BY Today;

	SET today = ADDDATE(today, 1);
END WHILE;
END #

DELIMITER ;

CALL taskListSelect();

DELIMITER #
CREATE TRIGGER temptrigger
AFTER INSERT ON tasklist FOR EACH ROW

BEGIN
DECLARE insertedid INT;
SET insertedid NEW.tasklistid;

INSERT INTO temptable (tempusername, temptaskid) VALUES (CURRENT_USER(), insertedid);
END #



CALL clearScheduleTables();
DROP TRIGGER taskListTrigger;

DELIMITER #
CREATE TRIGGER taskListTrigger
AFTER INSERT ON newtask FOR EACH ROW

BEGIN
DECLARE enddate DATE DEFAULT ADDDATE(CURDATE(), 5);
DECLARE today DATE DEFAULT CURDATE();
DECLARE year, month, week, weekday, day INT;
DECLARE newTaskID INT;
SET newTaskID = NEW.newtask;
WHILE today < enddate DO

	SET year = YEAR(today);
	SET month = MONTH(today);
	SET week = WEEK(today);
	SET weekday = WEEKDAY(today);
	SET day = DAYOFMONTH(today);


	INSERT INTO tasklist
	(taskid, taskname, tlistfulldate, tlisttime, tlistsystem, tlistcountry,
	tlistfuncarea, tliststate, tlistprocedure, tlistdescription, tlistcreatedate, tlistcreatename, tlistcreatestate)
	SELECT
	T.taskid,
	T.taskname,
	today,
	TT.starttime,
	T.tasksystem,
	T.taskcountry,
	T.taskfuncarea,
	T.taskinitstate,
	T.taskprocedure,
	T.taskdescription,
	T.taskcreatedate,
	T.taskcreatename,
	T.taskinitstate
	FROM  tasks T
	RIGHT JOIN taskdates TD on TD.taskid = NEW.newtask
	RIGHT JOIN tasktimes TT on TT.taskid = NEW.newtask
	WHERE
		TD.taskstartdate <= today
		AND
		(TD.year = year or TD.year = 'all')
		AND
		(TD.month = month or TD.month = 'all')
		AND
		(TD.week = week or TD.week = 'all')
		AND
		(TD.weekday = weekday or TD.weekday = 'all')
		AND
		(TD.day = day or TD.day = 'all')
		AND
		T.taskid = NEW.newtask;
		
	SET today = ADDDATE(today, 1);
END WHILE;
END #








DELIMITER #
CREATE PROCEDURE clearScheduleTables()
BEGIN
TRUNCATE TABLE tasks;
TRUNCATE TABLE tasklist;
TRUNCATE TABLE taskdates;
TRUNCATE TABLE tasktimes;
END#


DROP PROCEDURE clearScheduleTables
CALL clearScheduleTables();
DROP TRIGGER taskListTrigger;





SELECT
CONCAT(LPAD(MONTH(TL.tlistfulldate),2,0),'/',LPAD(DAYOFMONTH(TL.tlistfulldate),2,0)) AS 'Start Date',
TIME_FORMAT(TL.tlisttime, '%H:%i') AS 'Start Time',
CC.ClassCountryName AS Country,
TL.taskname AS Subject,
TS.taskstate AS Status,
CS.ClassSysName AS System
FROM tasklist TL, classcountry CC, classfuncarea CF, classsystem CS, taskstate TS, procedures P
WHERE
	TL.tlistfulldate >= CURDATE()
	AND
	TL.tlistsystem = CS.classsysid
	AND
	TL.tlistcountry = CC.classcountryid
	AND
	TL.tlistfuncarea = CF.classfuncid
	AND
	TL.tliststate = TS.taskstateid
	AND
	TL.tlistprocedure = P.procid
	AND
	TL.tlistcreatestate = TS.taskstateid
ORDER BY TL.tlistfulldate, TL.tlisttime;







CALL taskListSelect();

DELIMITER #
CREATE TRIGGER temptrigger
AFTER INSERT ON tasklist FOR EACH ROW

BEGIN
DECLARE insertedid INT;
DECLARE inserter VAR;
SET insertedid = NEW.tasklistid;

INSERT INTO temptable (tempusername, temptaskid) VALUES (CURRENT_USER(), insertedid);
END #



DELIMITER #
CREATE PROCEDURE historyBackup()
BEGIN
INSERT INTO tasklisthistory (tasklistid, taskid, taskname, tlistfulldate, tlisttime, tlistsystem,
	tlistcountry, tlistfuncarea, tliststate, tlistprocedure, tlistdescription, tlistcreatedate,
	tlistcreatename, tlistcreatestate)
SELECT tasklistid, taskid, taskname, tlistfulldate, tlisttime, tlistsystem,
	tlistcountry, tlistfuncarea, tliststate, tlistprocedure, tlistdescription, tlistcreatedate,
	tlistcreatename, tlistcreatestate FROM tasklist WHERE tlistfulldate < ADDDATE(CURDATE(), -4);
DELETE FROM tasklist WHERE tlistfulldate < ADDDATE(CURDATE(), -4);
END #


SELECT * FROM tasklist
ORDER BY tlistfulldate DESC
LIMIT 1


DELIMITER #
CREATE PROCEDURE updateTaskListTest()
BEGIN
DECLARE done INT DEFAULT FALSE;
DECLARE dectaskid INT;
DECLARE enddate DATE DEFAULT ADDDATE(CURDATE(), 3);
DECLARE startdate DATE;
DECLARE decfulldate DATE;
DECLARE year, month, week, weekday, day INT;
DECLARE cursortask CURSOR FOR SELECT taskid FROM tasks;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

OPEN cursortask;

	read_loop: LOOP
		FETCH cursortask INTO dectaskid;
		IF done THEN
			LEAVE read_loop;
		END IF;
		SELECT tlistfulldate INTO decfulldate FROM tasklist WHERE taskid = dectaskid ORDER BY tlistfulldate DESC LIMIT 1;
		IF decfulldate < enddate THEN
			SET startdate = ADDDATE(decfulldate, 1);
			WHILE startdate < enddate DO

				INSERT INTO temptable (taskdate, newdate, taskid, confirm) VALUES (decfulldate, startdate, dectaskid, 'YES');
					
				SET startdate = ADDDATE(startdate, 1);
			END WHILE;
		ELSE
			INSERT INTO temptable (taskdate, newdate, taskid, confirm) VALUES (decfulldate, startdate, dectaskid, 'NO');
		END IF;
	END LOOP;
CLOSE cursortask;
END #



DELIMITER #
CREATE PROCEDURE updateTaskList()
BEGIN
DECLARE done INT DEFAULT FALSE;
DECLARE dectaskid INT;
DECLARE enddate DATE DEFAULT ADDDATE(CURDATE(), 15);
DECLARE startdate DATE;
DECLARE decfulldate DATE;
DECLARE year, month, week, weekday, day INT;
DECLARE cursortask CURSOR FOR SELECT taskid FROM tasks;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

OPEN cursortask;

	read_loop: LOOP
		FETCH cursortask INTO dectaskid;
		IF done THEN
			LEAVE read_loop;
		END IF;
		SELECT tlistfulldate INTO decfulldate FROM tasklist WHERE taskid = dectaskid ORDER BY tlistfulldate DESC LIMIT 1;
		IF decfulldate < enddate THEN
			SET startdate = ADDDATE(decfulldate, 1);
			WHILE startdate < enddate DO

				SET year = YEAR(startdate);
				SET month = MONTH(startdate);
				SET week = WEEK(startdate);
				SET weekday = WEEKDAY(startdate);
				SET day = DAYOFMONTH(startdate);


				INSERT INTO tasklist
				(taskid, taskname, tlistfulldate, tlisttime, tlistsystem, tlistcountry,
				tlistfuncarea, tliststate, tlistprocedure, tlistdescription, tlistcreatedate, tlistcreatename, tlistcreatestate)
				SELECT
				T.taskid,
				T.taskname,
				startdate,
				TT.starttime,
				T.tasksystem,
				T.taskcountry,
				T.taskfuncarea,
				T.taskinitstate,
				T.taskprocedure,
				T.taskdescription,
				T.taskcreatedate,
				T.taskcreatename,
				T.taskinitstate
				FROM  tasks T
				RIGHT JOIN taskdates TD on TD.taskid = dectaskid
				RIGHT JOIN tasktimes TT on TT.taskid = dectaskid
				WHERE
					TD.taskstartdate <= startdate
					AND
					(TD.year = year or TD.year = 'all')
					AND
					(TD.month = month or TD.month = 'all')
					AND
					(TD.week = week or TD.week = 'all')
					AND
					(TD.weekday = weekday or TD.weekday = 'all')
					AND
					(TD.day = day or TD.day = 'all')
					AND
					T.taskid = dectaskid;
					
				SET startdate = ADDDATE(startdate, 1);
			END WHILE;
		END IF;
	END LOOP;
CLOSE cursortask;
END #



